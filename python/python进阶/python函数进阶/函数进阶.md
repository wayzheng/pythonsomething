# 函数进阶
## 目录
* [文档注释的编写](#文档注释的编写)
* [函数的参数详解](#函数的参数详解)
* [函数作用域和嵌套函数](#函数的作用域和嵌套函数)
* [通过使用lambda函数创建匿名函数](#lambda函数)
* [装饰器函数](#装饰器函数)
* [函数的递归调用](#函数的递归调用)
* [函数的闭包](#函数的闭包)
* [Map filter reduce函数的使用](#Map filter reduce函数的使用)
## 文档注释的编写
* 推荐使用google文档注释风格
* [google注释风格详解官方网站](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html)
* 分为以下几个部分
* 摘要
  * 一句话描述函数的功能
* 参数
* 返回值
* 示例
```python
def add(a, b):
    """
    这是一个加法函数
    这个函数的功能是对两个数字进行相加
    这个函数的参数有两个
    a: 第一个数字
    b: 第二个数字
    这个函数的返回值是两个数字的和
    这个函数的使用方法是add(1, 2)
    这个函数的示例是add(1, 2) => 3
    """
    return a + b
```
## 函数的参数详解
* 位置参数
    * 位置参数就是按照参数的位置进行传递
    * 位置参数的个数必须和函数的参数个数一致
    * 可以为位置参数来设置默认值
* 默认参数
    * 就是在定义函数的时候给参数设置默认值
    * 默认参数必须放在位置参数的后面
    * 默认参数可以覆盖位置参数的值
    * 默认参数的值是在函数定义的时候就已经确定的，而不是在函数调用的时候确定的
* 可变参数
    * 就是函数的参数个数不确定，可以是0个或多个
    * 可变参数在函数的参数列表中只能有一个，且必须放在最后一个位置参数之后
    * 可变参数的值是一个元组
    * 可变参数的值是在函数调用的时候确定的，而不是在函数定义的时候确定的
    * 可以通过*来定义可变参数 就是*args来表示的就是一个可变参数元祖 此时args就是一个元祖
    * 不一定非要是args 也可以是其他的名字
* 关键字参数
    * 关键字参数就是在函数调用的时候通过使用关键字来传递参数 关键字参数在函数调用的时候必须使用关键字来指定参数名
    * 关键字参数的值是一个字典
    * 关键字参数的值是在函数调用的时候确定的，而不是在函数定义的时候确定的
    * 可以通过**来定义关键字参数 就是**kwargs来表示的就是一个关键字参数字典 此时kwargs就是一个字典
    * 不一定非要是kwargs 也可以是其他的名字
    * 位置参数和关键字参数可以混合使用 但是位置参数必须在关键字参数的前面
    * 注意关键字参数的名字不能和位置参数和可变参数的名字相同o
## 函数的作用域和嵌套函数
* 函数的作用域就是函数内部可以访问的变量和函数
* 局部变量只能在函数内部访问，外部不能访问
* 全局变量可以在整个程序范围内访问
* 嵌套函数就是在一个函数内部定义另一个函数
* 嵌套函数可以访问外部函数的变量和参数
* 嵌套函数可以访问外部函数的作用域
* 嵌套函数可以访问外部函数的返回值
* 嵌套函数可以访问外部函数的全局变量
* 嵌套函数可以访问外部函数的嵌套函数
* 嵌套函数的作用域就是内部函数的作用域
## lambda函数
* lambda函数就是一个匿名函数
* lambda函数的语法是**lambda 参数:表达式**
* lambda函数的**参数可以有多个，但是表达式只能有一个**
* lambda函数的返回值是表达式的结果
* lambda函数的返回值是一个**函数对象**
* lambda函数的作用是定义一个简单的函数
* lambda函数的使用场景是在函数内部定义一个简单的函数
* 缺点就是无法写文档注释 无法写复杂的函数
## 装饰器函数
* 装饰器函数就是在不改变原函数的情况下，对函数进行扩展
* 装饰器函数的语法是**@装饰器函数名**
* 装饰器函数的返回值是一个函数对象
* 装饰器函数的作用是对函数进行扩展
* 装饰器函数的使用场景是在函数的前后添加一些功能
## 函数的递归代调用
* 函数的递归调用就是一种数学上的递归定义
* 函数的递归调用就是函数调用自己
* 函数的递归调用的终止条件是递归调用的参数满足某个条件
* 函数的递归调用的优点是代码简洁
* 函数的递归调用的缺点是性能差
* 使用的条件
    * 必须有一个明确的终止条件
    * 必须有一个明确的递归步骤
    * 必须有一个明确的递归函数
    * 必须有一个明确的递归出口
    * 必须有一个明确的递归入口
* 比如可以通过使用递归函数实现一个斐波那契数列 同时也是可以通过使用递归函数来时实现一个阶乘的计算
## 函数的闭包
* 闭包就是在一个函数的内部定义了另外的一个函数
* 通过这种方式就是可以让内部函数访问外部函数的变量和参数
* 闭包的作用就是可以让内部函数访问外部函数的变量和参数 从而实现对外部函数的拓展性
* 通过使用nolocal关键字就是可以让内部函数修改外部函数的变量
## 可迭代对象和迭代器和生成器
* 可迭代对象就是可以通过for循环来遍历的对象
* 可迭代对象的本质就是实现了__iter__方法的对象
* 可迭代对象的特点是可以通过iter函数来获取迭代器
* 迭代器就是实现了__next__方法的对象
* 迭代器的特点是可以通过next函数来获取下一个元素
* 迭代器的本质就是实现了__iter__和__next__方法的对象
* 生成器就是通过函数来实现的迭代器
* 生成器的特点是通过yield关键字来实现的
* 生成器的本质就是实现了__iter__和__next__方法的对象
* 生成器的特点是可以通过next函数来获取下一个元素
* 生成器的特点是可以通过send函数来传递参数
* 生成器的特点是可以通过throw函数来抛出异常
* 生成器的特点是可以通过close函数来关闭生成器
* 生成器的特点是可以通过yield from关键字来实现委托生成器
## Map filter reduce函数的使用
### Map函数
* map函数会将每一个函数都映射到一个输入列表中的元素上 
* 规范就是 map(function, iterable)
* 此时就是可以将function通过使用匿名函数的方式来写 从而实现简化代码的作用
* map函数的返回值是一个迭代器对象 通过使用list函数之后完成列表的转换之后 就是会导致迭代器对象完成了迭代之后 在通过使用list函数所得到的结果就是一个空的列表 就是已经完成了迭代
### filter函数 
* filter函数会对指定的序列执行某个函数 并且返回符合条件的元素组成的一个新的列表
* 规范就是 filter(function, iterable)
* 此时就是可以将function通过使用匿名函数的方式来写 从而实现简化代码的作用
### reduce函数
* reduce函数会对参数序列中元素进行从操作 从左到右进行操作 知道只剩下一个元素 作为结果进行返回
* 规范就是 reduce(function, iterable)
* 此时就是可以将function通过使用匿名函数的方式来写 从而实现简化代码的作用
