# 生成器
* [迭代器简介](#迭代器简介)
* [迭代器的实现](#迭代器的实现)
* [生成器表达式](#生成器表达式)
* [生成器函数](#生成器函数)
* [生成器的优点](#生成器的优点)
## 生成器简介
* 生成器是一种特殊的迭代器，它的元素是通过函数生成的。
* 背景就是有的时候我吗无法确定要生成多少个元素，这个时候就可以使用生成器。
* 就是我们需要的个数是不确定的， 我们就是可以考虑使用生成器 
* 通过使用迭代器虽然可以实现生成器 但是使用生成器更加方便
> 背景：通过使用列表生成器 我们可以直接创建一个列表 但是 受到内存的限制 列表的容量是有限的 而且如果需要创建需要包含大量元素的列表 就是会占用大量的内存 不仅仅会占用很大的内存空间 如果只是访问前面的几个元素 就是会浪费大量的内存空间<br />
> 所以 我们可以使用生成器来解决这个问题 因为生成器可以不用一次性生成所有元素 而是只生成需要的元素 这样就可以节省内存空间 <br />
> 通俗的理解就是 python中 这种一边进行循环一边计算的机制就是称为生成器 generator 
* 简单来说 如果需要额很多数据的列表 我们可以使用有两种方案 
1. 第一种就是直接一次性全部生成所有的数据 优点就是简单明了 缺点就是占用大量的内容
2. 第二种就是使用生成器 优点就是节省内存空间 缺点就是比较麻烦 不是特别容易理解
* 应用场景：如果是一次性全部生成 就是可以使用列表 如果需要的是什么时候要什么时候生成 就是可以已使用生成器 如果需要的数据比较少 就是可以已使用列表 推荐使用
* 什么是生成器：就是只记录生成数据的方式(算法) 而不是事先生成并且存储数据 这种方式就是称为生成器 generator
* 其实利用迭代器 可以通过使用next()方法来按照特定的规律来进行生成数据 但是实现迭代器的时候 关于当前的迭代到的状态就是需要我们自己来进行记录 进而可以根据当前状态来生成下一个数据  迭代器是可以通过循环来生成数据的 但是稍微有些复杂 有一个能具有迭代器的功能 并且比他更加简单的方式 就是 生成器 generator
* **生成器就是一种特殊的迭代器** 就是说迭代器可能是生成器 生成器一定是迭代器
## 生成器的实现 
* 方式一 
* 只要将一个列表生成式的[]改成了() 就是可以得到一个生成器
```python
a = [x for x in range(1, 10)]
print(type(a))
b = (x for x in range(1, 10))
print(type(b))
```
* 方式二
* 引例 斐波那契数列
### yield关键字 
* 只要有yield关键字 虽然看上去是调用一个函数 实际上就是已经变成了一个创建一个生成器对象
* 通过使用next()调用生成器 可以让这个yield的def代码块 开始执行
    * 如果是第一次执行 就是会从def代码块中的开始部分进行执行 直到遇到yield关键字 并且将yield关键字后面的数据进行返回 当做next()的返回值
    * 如果不是第一次执行 就是会从上一次暂停的位置开始执行 也就是说会从上一次yield关键字的下一个语句开始执行 知道遇到下一个yield关键字 并将yield关键字后的数据作为返回值来进行返回 作为next()的返回值