# 生成器
* [迭代器简介](#迭代器简介)
* [迭代器的实现](#迭代器的实现)
* [生成器表达式](#生成器表达式)
* [生成器函数](#生成器函数)
* [生成器的优点](#生成器的优点)
## 生成器简介
* 生成器是一种特殊的迭代器，它的元素是通过函数生成的。
* 背景就是有的时候我吗无法确定要生成多少个元素，这个时候就可以使用生成器。
* 就是我们需要的个数是不确定的， 我们就是可以考虑使用生成器 
* 通过使用迭代器虽然可以实现生成器 但是使用生成器更加方便
> 背景：通过使用列表生成器 我们可以直接创建一个列表 但是 受到内存的限制 列表的容量是有限的 而且如果需要创建需要包含大量元素的列表 就是会占用大量的内存 不仅仅会占用很大的内存空间 如果只是访问前面的几个元素 就是会浪费大量的内存空间<br />
> 所以 我们可以使用生成器来解决这个问题 因为生成器可以不用一次性生成所有元素 而是只生成需要的元素 这样就可以节省内存空间 <br />
> 通俗的理解就是 python中 这种一边进行循环一边计算的机制就是称为生成器 generator 
* 简单来说 如果需要额很多数据的列表 我们可以使用有两种方案 
1. 第一种就是直接一次性全部生成所有的数据 优点就是简单明了 缺点就是占用大量的内容
2. 第二种就是使用生成器 优点就是节省内存空间 缺点就是比较麻烦 不是特别容易理解
* 应用场景：如果是一次性全部生成 就是可以使用列表 如果需要的是什么时候要什么时候生成 就是可以已使用生成器 如果需要的数据比较少 就是可以已使用列表 推荐使用
* 什么是生成器：就是只记录生成数据的方式(算法) 而不是事先生成并且存储数据 这种方式就是称为生成器 generator
* 其实利用迭代器 可以通过使用next()方法来按照特定的规律来进行生成数据 但是实现迭代器的时候 关于当前的迭代到的状态就是需要我们自己来进行记录 进而可以根据当前状态来生成下一个数据  迭代器是可以通过循环来生成数据的 但是稍微有些复杂 有一个能具有迭代器的功能 并且比他更加简单的方式 就是 生成器 generator
* **生成器就是一种特殊的迭代器** 就是说迭代器可能是生成器 生成器一定是迭代器
## 生成器的实现 
* 方式一 
* 只要将一个列表生成式的[]改成了() 就是可以得到一个生成器
```python
a = [x for x in range(1, 10)]
print(type(a))
b = (x for x in range(1, 10))
print(type(b))
```
* 方式二
* 引例 斐波那契数列
### yield关键字 
* 只要有yield关键字 虽然看上去是调用一个函数 实际上就是已经变成了一个创建一个生成器对象
* 通过使用next()调用生成器 可以让这个yield的def代码块 开始执行
    * 如果是第一次执行 就是会从def代码块中的开始部分进行执行 直到遇到yield关键字 并且将yield关键字后面的数据进行返回 当做next()的返回值
    * 如果不是第一次执行 就是会从上一次暂停的位置开始执行 也就是说会从上一次yield关键字的下一个语句开始执行 知道遇到下一个yield关键字 并将yield关键字后的数据作为返回值来进行返回 作为next()的返回值
* 只要一个def 函数代码中包含了yield关键字 那么这个函数就是一个生成器函数
* 通过使用yield关键字 经常就是嵌套于一个while True循环当中 通过使用yield关键字来返回数值 进而实现生成器 
* 如果是第一次执行就是会从 def 代码块的开始部分惊进行执行 直到遇到了yield关键字 并且将yield关键字后面的数据作为返回只进行返回 通过使用next()返回来获取这个返回值
* 之后的每一次调用 都是会从yield之后的代码开始执行 通过while True循环来进行下一次的循环 知道再一次的遇到了yield关键字 并且将yield关键字后面的数据作为返回值来进行返回
* 定义一个生成器对象 可以使用多个yield关键字 来实现不同的特征表现的模式 如果在一个yield执行完成之后 再次调用next()方法 如果没有遇到下一个yield关键字 就是会抛出StopIteration的异常
### send唤醒
* 处理可以使用next()函数来唤醒 让生成器继续执行之外 还可以使用send()函数来唤醒生成器
* 通过使用send()函数来进行唤醒的好处就是 可以在唤醒的同时想断点处传入一个附加的数据
* 与next()的异同点
  * 相同点
    * 都是可以是生成器函数继续向下执行
    * 如果运行的时候 没有遇到下一个yield关键字 就是会抛出StopIteration异常
  * 不同点
    * next()函数不能传递参数 send()函数可以传递参数
    * 通过使用send()函数可以将传入的参数作为上一个yield关键字的返回值来进行使用 
```python
# 比如就是可以通过使用send()函数来传递参数
def gen():
    #  实现将send传入的参数累加
    total = 0
    while True:
      x = yield total
      total += x
def main():
    g = gen()
    print(next(g))  # 0
    print(g.send(1))  # 1
    print(g.send(2))  # 3
```
### 总结
1. 通过使用yield关键字的函数 不是函数 而是生成器对象
2. yield关键字的作用有两点
  * 保存当前的状态 相当与pycharm中的断点操作 然后暂停操作 就是将生成器挂起
  * 将yield关键字的后面的表达式的值作为返回值返回 此时可以理解成为起到了return的作用
3. 可以使用next()函数来唤醒生成器对象 就是让生成器从断点开始继续执行 直到遇到下一个yield关键字 并且将yield关键字后面的表达式的值作为返回值返回 如果没有遇到下一个yield关键字 就是会抛出StopIteration异常
4. 在一个生成器函数中 可以使用多个yield关键字来实现不同的特征表现的模式
5. 如果最后有一个return 返回值 可以作为整个生成器的返回值 可以通过使用StopIteration异常的value属性来获取
6. 生成器是这样的一个函数 他记住了上一次返回时在函数的位置 对生成器函数的第二次或者第N次调用直接跳转到该函数中间 而上次调用的所有的局部变量的状态都保持了下来 生成器不仅记住了他的数据状态 还记住了它在流控制构造中的位置
7. 生成器的特点 存储的是生成数据的方式 而不是存储生成的数据 所以节省了内存空间