# 可哈希和不可哈希之辩
## 目录
* [哈希简介](#哈希简介)
* [可哈希](#可哈希)
* [不可哈希](#不可哈希)
* [总结]
## 哈希简介
* 简单的介绍： 哈希就是一种将任意长度的数据转化为一个固定长度的数字或者字符串的函数
* 哈希的作用： 哈希的作用就是为了快速查找数据，比如在一个大型的数据库中，我们可以根据关键词快速找到对应的记录，而不需要遍历整个数据库。
* 哈希的原理： 哈希的原理就是将任意长度的数据转化为一个固定长度的数字或者字符串的函数。
## 可哈希
* 简单来说就是不可以变化的一个数据结构 在python中 不可变的数据就是可哈希的 具体类型有： 数字类型(int float boolean) 字符串类型 元祖类型 自定义类的对象
* 对于不可变类型的数据类型 就是可以表示成为一个唯一的数字或者字符串的哈希值，可以快速的查找和比较。不可变类型的数据类型在内存中的地址就是唯一的值 可以通过使用id()就是可以获得内存地址
* 可以通过使用hash()来获取一个可哈希类型的哈希值 这个哈希值是通过内部的__hash__()魔法函数进行定义的
* 举例：
```python
a = 10
b = 20
print(id(a)) # 4471224000
print(id(b)) # 4471224008
```
## 不可哈希
* 简单的来说就是一个可以变化的一个数据结构 在python中 可变的数据结构就是不可哈希的 具体类型有： 列表 字典 集合
* 对于可变类型的数据类型 内存中的地址是不固定的 不能表示成为一个唯一的数字或者字符串的哈希值 不能快速的查找和比较。
* 举例：
```python
a = [1, 2, 3]
b = [1, 2, 3]
print(id(a)) # 4471224000   
a.append(4)
print(id(a)) # 4471224000
print(id(b)) # 4471224008
```
## 总结
* 哈希是一种将任意长度的数据转化为一个固定长度的数字或者字符串的函数，用于快速查找数据。
* 如果改变一个对象的值 但是这个值的地址没有发生改变 那么这个对象就是不可以哈希的 就是unhushable
* 如果改变一个对象的值 但是这个值的地址发生了改变 那么这个对象就是可以哈希的 就时hashable
```python
# 比如对于一个数字类型的对象
a = 10
print(id(a))
a = 20
print(id(a))
# 此时所得到的结果是不一样的 就是地址发生了改变
# 对于一个可不变类型的数据类型
a = [1, 3, 5, 7]
print(id(a))
a.append(9)
print(id(a)) # 此时对象的地址没有发生改变 但是值发生了改变 所以此时对象就是不可以哈希的 所以对于字典来说 键值对的顺序是不可以哈希的只能是可哈希的 不然的话
# 对于一个可变类型的数据类型
a = [1, 3, 5, 7]
print(id(a))
a.append(9)
```
## 更加深入的讨论
* 可哈希就是指的是 如果一个对象是一个可以哈希的 那么在它的生命周期内必须就是不可以变得 并且该对象需要一个哈希函数 而且可以和其他对象进行比较(此时就是需要通过使用比较方法) 比较值相同的对象就是一定有相同的哈希值 也就是说一个对象就是必须要包含以下几个魔法函数
* __eq__() 就是用来比较两个对象是否相等
* __cmp__() 就是用于比较两个对象的大小关系的 它与__eq__()方法只要有一个就可以了
* __hash__() 实际上就是哈希函数(就是散列函数) 返回经过运算得到的哈希值
* 但是并不是有了上述方法的对象 就一定是可哈希的 因为有些对象比如列表 字典 集合 他们的哈希值是不固定的 所以不能够通过哈希函数来得到固定的值 所以对于这些对象来说 并不是一定要有哈希函数 但是如果有的话 那么就必须要有__hash__()方法
* 比如对于列表而言 列表实现了__hash__ __eq__方法 但是通过hash(list对象) 最终就是会抛出异常错误 而这个异常错误就是通过使用__hash__方法来实现的
### 自定义哈希对象
* 自定义类的对象是可以哈希的
* 自定义类的对象如果想要实现可哈希 那么就必须要实现__hash__方法 并且返回一个固定的值或者通过某种计算来获取一个固定的值
### 字典的实现方式
* 字典的工作方式就是通过使用hash()内置函数计算字典中存储的每一个键的哈希值 hash代码根据键和每一个进程的种子而变化很大
* 字典就是通过键值的哈希值来确定存储位置的 所以字典的键值必须是可哈希的 否则就会出现哈希冲突 导致查找和插入的效率下降
### 通过使用哈希就是可以来自定义个实现字典对象
* 就是通过某一个方式来表示键值 就是将键值转化为一个哈希值 所以最关键的就是一个哈希值的算法的问题 如果创建一个补充负的哈希值是字典类型的键值的核心所在